Task 1:

The commands executed:
1. whoami
2. groups
Outputs:
1. mifta
2. mifta adm dialout cdrom floppy sudo audio dip video plugdev users netdev

Explanation:
whoami: I used the whoami command to find my login username. This command ouput my computers username "mifta" which is my name and username for my account.
groups: This command showed my all usergorups that my user account "mifta" belongs to. I observed a list of all group names including my main user group. 



task2:

The commands executed:
1.pwd
2.ls -l

Outputs:
1./mnt/d/My PC/Desktop/linux_lab_assignment/question_1
2.total 48
-rwxrwxrwx 1 mifta mifta   559 Jan  4 21:39 explanation.txt
-rwxrwxrwx 1 mifta mifta 46377 Jan  4 21:37 task1.png

Explanation:
1.I executed the pwd command to print the absolute path of the current working directory. This confirms exactly where in the file system the session is currently located.
2.I used the ls command with the -l flag to display the contents in a long-format list. This allowed me to observe detailed information such as file permissions, ownership, size, and modification dates for all items in the directory.




task3:
the commands executed:
1.echo "Linux user environment verified" > user_info.txt
2.cat user_info.txt

outputs:
1:
2:

Explanation:
1.I used the echo command combined with the > redirection operator to create the file and insert the specified text. This process overwrites any existing file with the same name to ensure the environment status is recorded accurately.
2.I ran the cat command to read the contents of the newly created file. I observed that the string "Linux user environment verified" was successfully saved within the document.




task4:
the commands executed:
1.wc -m user_info.txt
2.man wc
outputs:
32 user_info.txt


outputs:
1:32 user_info.txt

Explanation:
1.I used the wc command with the -m flag to calculate the character count of the file. I observed the output which confirms the total number of characters, including the text and the trailing newline character.
2.I accessed the manual page for the wc (word count) tool to review its full capabilities and various flags. This allowed me to verify that -m is the correct option for counting characters specifically, as opposed to bytes or lines.



task5:
the commands executed:
1.man mkdir
2.mkdir -p parent_folder/child_folder

output:output is too big.I included it in the screenshots.


Explanation:
1.I accessed the manual page for the mkdir utility to examine its documentation and available command-line flags. I observed a comprehensive list of options that control how new directories are created.
2.I identified the -p (parents) option, which allows for the creation of nested directory structures in a single command. I observed that it automatically creates any missing parent directories and ignores the command if the directory already exists, preventing errors.

task6:
commands:
1.ls ~
2.ls -F ~

output:
1.first_folder
2.first_folder/



Explanation:
1.I used the ls command followed by the tilde (~) symbol, which represents the home directory path. I observed the contents listed in the default alphabetical order, allowing for easy identification of user files and folders.

2.I ran the list command with the -F flag to add indicators to the alphabetical entries, such as a forward slash (/) for directories. This helped me quickly distinguish between plain files and sub-directories within the home folder.


task7:
grep "admin" log.txt

output:
grep: log.txt: No such file or directory

Explanation:
I executed the grep command to isolate and display only the lines within log.txt that contain the string "admin". This filtered the output to show matching log entries exclusively.


task8:
uname -r


output:
6.6.87.2-microsoft-standard-WSL2

Explanation:
I executed the uname command with the -r flag to retrieve the specific release version of the running Linux kernel. This allowed me to observe the exact kernel build currently supporting the operating system.


task9:
commands:
ping -c 4 www.google.com


outputs:
PING www.google.com (172.253.122.99) 56(84) bytes of data.
64 bytes from bh-in-f99.1e100.net (172.253.122.99): icmp_seq=1 ttl=100 time=62.9 ms
64 bytes from bh-in-f99.1e100.net (172.253.122.99): icmp_seq=2 ttl=100 time=60.7 ms
64 bytes from bh-in-f99.1e100.net (172.253.122.99): icmp_seq=3 ttl=100 time=65.1 ms
64 bytes from bh-in-f99.1e100.net (172.253.122.99): icmp_seq=4 ttl=100 time=61.7 ms

--- www.google.com ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3542ms
rtt min/avg/max/mdev = 60.676/62.593/65.057/1.629 ms


Explanation:
I used the ping command with the -c 4 flag to send four ICMP echo requests to the specified host. I observed the statistics for transmitted and received packets to confirm the network connection is active and stable.



task10:
commands:
 uptime

outputs:
22:49:49 up  1:25,  1 user,  load average: 0.04, 0.02, 0.00

Explanation:
I executed the uptime command to view how long the system has been running since the last boot. I observed the output which provides the current time, the total uptime duration, the number of currently logged-in users, and the system load averages for the past 1, 5, and 15 minutes.


